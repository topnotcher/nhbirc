package com.coldsteelstudios.irc;

import java.net.Socket;
import java.io.PrintWriter;
import java.io.BufferedReader;
import java.io.InputStreamReader;

//import java.util.concurrent.PriorityBlockingQueue;
//import java.util.concurrent.BlockingQueue;
import com.coldsteelstudios.util.PriorityBlockingQueue;
import com.coldsteelstudios.util.BlockingQueue;

import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;

import java.util.Set;
import java.util.TreeSet;
import java.util.regex.Pattern;

/**
 * Connects to, registers with an IRC server and dispatches events.
 *
 *
 * @TODO need to make the exception handling better
 * This might mean a way to register exception handlers or something, 
 * as currently most of the exceptions will occur in different threads.
 */
public class Connection {

	/**
	 * State of the connection
	 */
	public static enum State {
		/**
		 * Completely not connected
		 */
		DISCONNECTED(0),

		/**
		 * TCP Connection complete, registration phase incomplete.
		 */
		CONNECTED(1),

		/**
		 * Connection is usable.
		 */
		REGISTERED(2);

		private int code;

		State(int code) {
			this.code = code;
		}
	}

	/**
	 * Minimm time in between pings. (milliseconds)
	 * If the connection is dropped, a ping will be sent to the server once
	 * every PING_TIMEOUT milliseconds.
	 */
	private static final int PING_TIMEOUT = 30000;

	/**
	 * Maximum idle time of the connection.
	 *
	 * If there is no activity fromt he server within this time, the
	 * connection will be closed.  The server will be pinged if it there is no
	 * activity for half this time. (see PING_TIMEOUT)
	 */
	private static final int MAX_IDLE = 1000*60*3;


	/**
	 * Server for the IRC connection
	 */
	private String host;

	/**
	 * Port of the IRCd on host.
	 */
	private int port;

	/**
	 * Current nickname of the registered connection.
	 */
	private String nick;
	
	private String defaultNick;
	/**
	 * The user/ident.
	 * @TODO get this from the server? The sever doesn't necessarily accept what we give it (identd, ~)
	 */
	private String user;
	
	/**
	 * The realname the connection was registered with.
	 */
	
	private String real;
	
	/**
	 * Password to use when registering.
	 */
	private String pass = null;

	/**
	 * The object that handles the actual socket i/o
	 */
	private Connection conn;

	/**
	 * Tracks the state of the connection.
	 * @see Connection.State
	 */
	private State state;

	/**
	 * Broker for events generated by this
	 */
	private EventManager events;

	/**
	 * The hostname the server gave as the origin in the 001 reply.
	 */
	private String hostname = "none";

	/**
	 * Create a Connection with a default ident and realname.
	 *
	 * @param host the hostname/Ip of the server.
	 * @param port the tcp port
	 * @param nick the nickname, realname, ident to use (copied to all 3)
	 */
	public Connection(String host, int port, String nick) {
		this(host,port,nick,nick);
	}

	/**
	 * Create a Connection with a nickname and username, but default realname
	 *
	 * @param host the hostname/Ip of the server.
	 * @param port the tcp port
	 * @param nick the nickname, realname, to use
	 * @param user ident/user to use.
	 */
	public Connection(String host, int port, String nick, String user) {
		this(host,port,nick,user,nick);
	}

	/**
	 * Create a Connection with a nickname and username, but default realname
	 *
	 * @param host the hostname/Ip of the server.
	 * @param port the tcp port
	 * @param nick the nickname to use
	 * @param user the ident/user to use.
	 * @param real the realname to use.
	 */
	public Connection(String host, int port, String nick, String user, String real) {
		this.user = user;
		this.host = host;
		this.port = port;
		this.nick = nick;
		this.defaultNick = nick;
		this.user = user;
		this.real = real;

		state = State.DISCONNECTED;
		
		events = new EventManager(this);
	}
	
	/**
	 * Set the password for the connection
	 *
	 * @param pass the password to use during registration
	 */
	public void setPass(String pass) {
		this.pass = pass;
	}

	/**
	 * Change the connection state: disconnected->connected->registered.
	 */
	private void setState(State ns) {
		state = ns;

		synchronized(this) {
			notifyAll();
		}
	}

	public State getState() {
		return state;
	}

	public String getServerName() {
		return hostname;
	}

	public Connection getConnection() {
		return this;
	}


	/**
	 * Attempt to connect to the given IRC server
	 * with the given parameters
	 *
	 * @TODO wrap IOException
	 */
	public void connect() throws ConnectionException {

		try {
			//connect
			//(blocks until connected)
			conn = new IrcConnection();
		} catch (java.io.IOException e) {
			throw new ConnectionException(e);
		}

		if ( state != State.CONNECTED )
			throw new ConnectionException("Connection is not connected!");


		//handle messages in a separate thread
		//so the socket I/O never pauses
		//(This can be important in the case of a flood of messages which require
		//some potentially long, synchonous operation to handle. In this case,
		//a PING could be left unread which would cause a pint timeout.
		//)
		(new Thread( new Worker(), "Message Handler" )).start();
	
		//initiatite registration
		register();

		try {
			/**
			 * Block for a state change, up to 30 seconds.
			 */
			synchronized(this) {
				this.wait(30000); 
			}

		} catch (InterruptedException e) {
		}

		/**
		 * 	Either state changed, or 30 seconds passed,
		 * 	so if the connection isn't registered, something went wrong.
		 */
	
		if ( state != state.REGISTERED )
			throw new ConnectionException("REGISTER timeout after 30 seconds");

		//the connection is registered, so the client is now in a usable state and can execute commands.
	}

	/**
	 * This is some fucking cheezy assshit!
	 */
	private void autoreconnect() {
		final int delay = 10000;

		//note: there is some potentially fucked up shit going on here.
		//I believe that if it autoreconnects too fast, the reader/writer threads
		//in the worker are still running (blocking). When they interrupt,
		//the connection state is set to connected again, but they detect an error and
		//disconnect. IN theory sleeping FIRST here is a cheap fix
		while (true) try {
			try { Thread.sleep(delay); } catch (Exception ex) {}
			connect();
			break;
		} catch (ConnectionException e) {	
			continue;
		}
	}

	//initiate registration
	private void register() {
		//All the commands in this method must go through sendRaw.

		//command order per RFC2812
		if ( pass != null )
			send("PASS",pass);
		
		//@TODO
		send("NICK", defaultNick);
		send("USER" ,user, "0", "*", real);
	}

	/**
	 * Issue the nick command...
	 */
	public void nick(String nick) {
		//send the nick command...	
		send("NICK", nick);

		//@TODO this is a slight problem as we should only set it it when we get the response
		//but registration doesn't return the response. AH, I see
		//I had removed this and made it set the default, but the nick in use code also calls this..
		this.nick = nick;

		//@TODO monitor for failed nick changes.
		//only set the nick on a successful reply..
	}


	/**
	 * The following are helper methods for IRC commands.
	 * Please read the relevant RFC for documentation. 
	 * DOcumenting IRC commands is beyind the scope of these comments.
	 * Kthanxbai.
	 */

	public void part(String chan, String msg) {
		if (msg != null)
			send("PART", chan, msg);
		else 
			send("PART", chan);
	}

	public void part(String chan) {
		part(chan,null);
	}

	public void join(String ... chans) {

		if (chans.length == 0)
			throw new IllegalArgumentException("Must pass a channel to join!");

		StringBuilder buf = new StringBuilder(chans[0]);	

		for ( int i = 1; i < chans.length; buf.append(',').append(chans[i]), ++i);

		send("JOIN",buf.toString());
	}

	public void msg(String target, String msg) {
		send("PRIVMSG",target, msg);
	}

	public void action(String target, String msg) {
		ctcp(target, "ACTION", msg);
	}

	public void ctcp(String target, String command,String msg) {
		msg(target,"\u0001" + command + " " + msg + "\u0001");
	}

	public void notice(String target, String msg) {
		send("NOTICE" ,target, msg);
	}

	public void kick(String chan, String user, String msg) {
		send("KICK", chan, user, msg);
	}

	public String nick() {
		return this.nick;
	}

	public String defaultNick() {
		return this.defaultNick;
	}

	public void quit() {
		quit("Client exited.");
	}

	public void quit(String msg) {
		send(Priority.LOW, "QUIT", msg);
	}

	/**
	 * End IRC helper methods.
	 */


	/**
	 * Below... about 50 varieties of send....
	 */

	private void send(String[] args, Priority p) {

		if (args.length == 0) return;

		StringBuilder buf = new StringBuilder(args[0]);	

		for ( int i = 1; i < args.length; buf.append( (i == args.length - 1) ? " :" : ' ').append(args[i]), ++i);
		
		send(buf.toString(), p);
	}

	private void send(Priority p, String... args) {
		send(args,p);
	}

	public void send(String ... args) {
		send(args,Priority.MEDIUM);
	}


	public void send(String msg) {
		send(msg, Priority.MEDIUM);
	}

	private void send(String msg, Priority p) {
		sendRaw(msg,p);
	}

	private void sendRaw(String cmd) {
		sendRaw(cmd, Priority.MEDIUM);
	}

	private void sendRaw(String cmd, Priority p) {

		@TODO
	}



	/**
	 * Registers a message handler (by default, to receive all messages).
	 * Messages can be filtering by chaining filter methods onto 
	 * the returned subscription.
	 *
	 * NOTE: The message subscriptions are backed by an ordered date structure.
	 *       The MessageHandler guarantess that handlers are called in the order
	 *       in which they were registered.
	 *
	 * @see MessageSubscription
	 * @return Provides a fluent interface...
	 */
	public MessageSubscription addMessageHandler(MessageHandler handler) {
		return events.register(handler);
	}

	public void handle(Message msg) {

		if ( msg.getCode() == MessageCode.RPL_WELCOME ) {
			setState(State.REGISTERED);
			hostname = msg.getSource().getHost();
		}
		
		//@TODO huge mess
		//	-handle erroneous nickname by choosing a random one.
		//	-nick collision won't happen during registration.
		//	-handle collision the same as in use.
		} else if ( state == State.CONNECTED &&
				(
				 /*msg.getCode() == MessageCode.ERR_ERRONEUSNICKNAME ||*/
					msg.getCode() == MessageCode.ERR_NICKNAMEINUSE ||
					msg.getCode() == MessageCode.ERR_NICKCOLLISION 
				)
		) {
			//I'm ASSUMING that all of these replies have the same format.
			//server 433 * nick :reason
			String bad = msg.getArg(2);

			//if I'm right about all of this, it should keep tacking on a _ until it
			//doesn't get a bad response...
			nick(bad+"_");

			//connected, but not registered...
			//In this case (99% sure), there will only be a 433, and no nick reply confirming the change.
			//(GOD irc is annoying)
			nick = bad+ "_";

		//nick reply indicating that I changed my nick...
		} else if ( msg.getType() == MessageType.NICKCHANGE && msg.getSource().getNick().equals(nick) ) {
				nick = msg.getTarget().getNick();
		}
	}

	//message handler thread
	private class Worker implements Runnable {

		private Worker() {}

		public void run() {
			while( state != State.DISCONNECTED ) {

				long rx_time = System.currentTimeMillis() - last_rx;
				long ping_time = System.currentTimeMillis() - last_ping;

				//ping timeout
				if ( (rx_time > MAX_IDLE) || (rx_time > PING_TIMEOUT && ping_time >= PING_TIMEOUT/2 && ping_time < 2*PING_TIMEOUT ) ) {
					System.err.println("PING TIMEOUT");
					conn.close();
				}
				
				//active keep-alives.
				else if ( ((System.currentTimeMillis() - last_tx > MAX_IDLE/2) || (System.currentTimeMillis() - last_rx) > MAX_IDLE/2) ) 
					ping();

				Message msg = null;

				try {
					msg = recvQ.poll(PING_TIMEOUT/3, java.util.concurrent.TimeUnit.SECONDS);
				} catch (InterruptedException e) {
					e.printStackTrace();
				}

				//nothing to do
				if (msg == null) continue;
				
				handle(msg);
				events.dispatch(msg);
			}
			return;
		}
	}
}
